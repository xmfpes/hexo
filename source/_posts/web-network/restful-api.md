---
title: Restful API
date: 2017-10-23 18:06:08
tags: 
- HTTP
categories:
- CS
- Network & Web
---

# Restful API(Representational State Transfer)

![](/images/web/rest.png)

- 웹의 자원들에 대해 고유한 URI를 부여해서 활용
- 자원을 정의하고, 자원에 대한 주소를 지정하는 방법의 전반을 의미한다.
- Restful API는 REST 특징을 지키면서 API를 제공하는 것을 의미한다.



Restful API를 한마디로 정의하기 전에 REST 특징에 대해 설명해야 하는데..



*REST란 웹에 존재하는 모든 자원들(이미지, DB 자원 등)에 고유한 URI를 부여해 자원을 활용하며, 그 자원에 대한 행위는 HTTP method(GET, POST, PUT, DELETE ..)로 표현하는 것을 말한다*

**Restful API란 결국, 위의 REST 특징을 지키면서 API를 제공하는것을 의미한다.**

Restful API는 모바일과 같은 클라이언트들이 등장하면서, Backend 하나로 웹 모바일 등 다양한 기기를 지원할 수 있게 되었다.

 

- ### REST의 특징

- **Uniform (유니폼 인터페이스)**

URI로 지정된 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.

- **Stateless (무상태성)**

REST는 무상태성 성격을 갖습니다. 작업을 위한 상태정보를 따로 저장하지 않습니다.쿠키나 세션 정보를 별도로 저장하지 않아, API 서버는 요청만을 단순히 처리하면 되기 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 처리를 하지 않아 구현이 단순해집니다.

- **Cacheable (캐시 가능)**

REST의 가장 큰 특징중 하나는 HTTP라는 기존 웹 표준을 그대로 사용하기 때문에, HTTP가 가진 캐싱 기능 적용이 가능합니다.

Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다.

첫 요청의 경우, E-Tag가 존재하지 않기 때문에 정상적인 요청을 통해 데이터를 받고 이후 E-Tag에 해싱 값을 클라이언트에서 가지고 있습니다. 서버측에서 이 해싱 값을 비교해 변경이 된다면 서버에 요청을 통해서 데이터를 받아옵니다. 만약 해싱 값이 같다면 변경이 일어나지 않은 것이고 이 경우에는 304 요청을 통해 데이터를 반환하지 않습니다. 그럴 경우 클라이언트는 브라우저에 캐싱된 값을 이용해 데이터를 표시하게 됩니다.

Last-Modified E-Tag 는 아마 우선순위가 있을 것이다.


**Last-Modified**

엔터티가 마지막으로 변경된 시각에 대한 정보를 제공한다. (파일인 경우 파일 시스템이 제공해 준 최근 변경 시각, 동적으로 생성된 리소스라면 응답이 만들어진 시간)

**E-Tag**

메시지에 담겨있는 엔터티를 위한 엔터티 태그를 제공한다. 이를 활용하여 리소스를 식별할 수 있다.

- **Self-descriptiveness (자체 표현 구조)**

REST의 특징중 하나는, REST API 메세지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어있는 것입니다.

- **Client - Server 구조**

REST 서버는 API 제공만을 하며 클라이언트와 서버간의 역할이 확실히 구분되기 때문에 각각 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.

- **계층형 구조**

REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드밸런싱, 암호화 계층을 추가해 구조상의 유연성을 들 수 있고 PROXY 게이트웨이같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.

게이트웨이를 통해서 



### RMM(Richardson의 성숙 모델)을 통한 REST 요소 이해

- 레벨 0

HTTP를 통해 데이터를 주고 받지만, POST만 사용하며 모든 요청 응답에 관한 정보는 body의 정보를 이용해 진행하는 단계

특정 서비스를 위해 클라이언트에서 접근할 endpoint가 하나이다. 하나의 endpoint에서 body를 읽어 요청을 처리하고 응답한다.



- 레벨 1

URL을 달리함으로써 리소스를 구분한다. endpoint는 여러개이지만, method를 구분하진 않는다. POST 요청만 사용한다.

/users, /board ….



- 레벨 2

레벨 1의 URL을 통해 어떤 리소스에 대한 것인지 구분하면서, HTTP method를 조합하여 어떤 행위를 할 지를 구분한다.

현재 가장 많은 Restful API가 이 형태의 단계를 제공하고 있다.



웹의 존재에 의해 지지되는 핵심 요소들은 발생한 에러의 종류를 커뮤니케이션하기 위해 **상태 코드-Status Code**를 사용하는 것과 함께 **안전한 오퍼레이션(예 GET)과 안전하지 않은 오퍼레이션 간의 강한 분리를 제공**하는 것이다.

안전한 오퍼레이션이라는 것은, GET 요청의 경우 서버의 데이터를 변경하지 않는 요청이기 때문에 안전한 요청이라는 것이다.
기존에 POST만 사용할때는 이런 요청들 간의 구분이 힘들었는데, POST,GET 등으로 나누면서 이런 요청에 대한 분리가 가능하다는 것이다.



- 레벨 3

HATEOAS(Hypertext As The Engine Of Application State)라고도 이야기한다.

이 단계의 핵심은 특정 API를 요청한 후 다음 단계로 할 수 있는 작업을 알려주는 것이며, 다음 단계의 작업을 위한 리소스의 URI를 알려주는 것이다.

이 단계는 적용하면 클라이언트에 영향을 미치지 않으면서 서버를 변경하는 것이 가능해 진다는 것이다.

클라이언트에 영향을 미치지 않는다는건, 객체 자체에 리소스를 받는 url을 가지고 있기 때문에 서버에서 api 리소스 정보를 바꿔도 클라이언트측에서는 유저에 담긴 정보를 이용해 요청을 보내기 때문에 영향을 미치지 않는다는 것이다.

user 3번 아이디를 가지는 객체가 있다고 가정 할 때, 유저 자체에 DELETE, user/3 이라는 리소스를 객체 내에 직접 가지게 하는 구조가 레벨 3의 구조이다.










